Uebersicht: Datenstrukturen und Data Tables fuer Unreal Engine 5
Um die im SoA-Editor gepflegten Inhalte in Unreal Engine 5 zu verwenden, sollten fuer jede Datenkategorie passende Blueprint-Structs und Data Tables erstellt werden. Alle Kernmodelle im Repository nutzen ULIDs als primaerschluessel (`id`) und zusaetzlich sprechende Slugs (`slug`). In UE5 empfiehlt es sich, den `slug` als Row Name zu verwenden (gut lesbar), den ULID-String aber als eigenes Feld in der Struct zu speichern, damit Querverweise stabil bleiben. Importiert wird bevorzugt ueber CSV- oder JSON-Exports, die Feldnamen muessen exakt mit den Struct-Feldern uebereinstimmen. Alle Loesungen bleiben blueprint-only; optionale Enums lassen sich als Blueprint-Enums abbilden, um die Editor-Bedienung zu vereinfachen. Alle Blueprint-Enums muessen die Backend-Strings unveraendert uebernehmen, damit CSV/JSON-Importe fehlerfrei greifen.

Arbeitsmodus: "Heute zu tun" Checkliste (damit klar ist, wo du stehst)
1) Ein Systemblock auswaehlen (z.B. Stats/Attributes oder Dialogue).
2) Fuer den Block: Blueprint-Enums anlegen und Strings 1:1 uebernehmen.
3) Struct(s) anlegen und Felder exakt wie Export benennen.
4) DataTable erstellen und Import testen (1-2 Beispielzeilen).
5) Validation-Notiz: Welche IDs verlinken auf andere Tabellen?
6) Im BP_GameDataSubsystem: Cache-Map fuer diesen Block anlegen.
7) Ergebnis markieren: "Block X fertig importiert + gecacht".

Runtime-Architektur (Lyra-inspiriert, Blueprint-only, ohne GAS)
- DataTables sind Import-Quelle, nicht die Runtime-Datenbank.
- Beim Spielstart: DataTables in Registry-Maps cachen (ULID -> Struct, Slug -> Struct).
- Kommunikation ueber Message-Events statt direkte Manager-Aufrufe (entkoppelt).
- SoftObjectReferences fuer Assets (Icons, Portraits, VO) statt harter Pfad-Strings, wo moeglich.

Konkrete Runtime-Bausteine
- BP_GameDataSubsystem: laedt DataTables, baut Cache-Maps, bietet Lookup-Funktionen.
- BP_MessageHub (oder Gameplay Message Subsystem): Events wie FlagChanged, QuestAdvanced, RewardApplied.
- BP_FlagManager/BP_QuestLog: verwalten Zustand, senden Events, reagieren auf Events.

Import-Workflow (Schritt-fuer-Schritt, wiederholbar)
1) Export aus SoA-Editor (CSV oder JSON).
2) Dateien nach `Content/Data/Exports` kopieren.
3) Blueprint-Enum(s) aktualisieren oder neu erstellen.
4) Struct(s) pruefen: Feldnamen = Export-Spalten.
5) DataTable importieren oder reimportieren.
6) BP_DataImportManager laufen lassen (Validation: fehlende ULIDs, Enum-Mismatch).
7) BP_GameDataSubsystem neu laden, Cache-Maps aktualisieren.
8) Ergebnis notieren: "Import OK" oder "Fehlerliste".

Kommunikationsregeln (damit Systeme nicht verdrahtet sind)
- Keine direkte Manager-zu-Manager-Calls fuer Gameplay-Flows.
- Events senden: FlagChanged, RequirementPassed, QuestCompleted, RewardGranted.
- Listener entscheiden lokal, was sie tun (UI refresh, Inventory update, Story advance).

Empfohlene Reihenfolge fuer Structs + Imports (MVP zuerst)
1) Core: Stats, Attributes, AttributeStatLink
2) Progression: CharacterClasses, Items, Item Stat/Attribute Modifiers
3) Narrative Spine: Flags, Requirements + Link-Tabellen, Quests, StoryArcs, Dialogues, DialogueNodes
4) World: Locations, Characters, Factions, Encounters, Events, Lore, Timelines
5) Combat: Abilities, Ability Links, Effects, Combat Profiles
6) Economy: Currencies, Shops, ShopInventory

Character/Profile Umbau - Start jetzt (Enums zuerst, dann Structs)
Enums (Phase 1 - zuerst anlegen, Strings 1:1 wie Backend):
- EInteractionRole: Questgiver, Merchant, Trainer, Companion, Story, Background
- EEnemyType: beast, undead, humanoid, elemental, machine, boss, demon, dragon, giant, spirit, other
- EEnemyAggression: Hostile, Neutral, Friendly
- EEncounterContext: Combat, Interaction
- ECombatSide: Hostile, Friendly, Neutral

Structs (Phase 2 - danach anlegen, Details siehe unten):
- FCharacterData
- FInteractionProfileData (+ FInteractionItemForSale)
- FCombatProfileData (+ FLootEntry, FCurrencyReward, FReputationReward, FCompanionConfig, FCompanionProgression, FCompanionStatGrowth)
- FEncounterParticipant (in FEncounterData)

Blueprint-To-Do (Character/Profile Block, Schritt fuer Schritt)
Hinweis: Feldnamen in Structs muessen exakt den Export-Spalten entsprechen (snake_case). RowName nutzt slug, wenn vorhanden; bei Profilen ohne slug RowName = id.

1) Struct FCharacterData (DataTable: characters)
- RowName: slug (aus Export-Spalte "slug")
- Felder:
  - id (String)
  - slug (String)
  - name (String)
  - title (String)
  - description (Text)
  - home_location_id (String)
  - faction_id (String)
  - class_id (String)
  - level (Integer)
  - image_path (String)
  - tags (Array<String>)

2) Struct FInteractionItemForSale (Sub-Struct)
- Felder:
  - item_id (String)
  - price (Float)

3) Struct FInteractionProfileData (DataTable: interaction_profiles)
- RowName: id (keine slug-Spalte vorhanden)
- Felder:
  - id (String)
  - character_id (String)
  - role (Enum/String) -> EInteractionRole
  - dialogue_tree_id (String)
  - available_quests (Array<String>)
  - inventory (Array<Struct>) -> FInteractionItemForSale
  - flags_set_on_interaction (Array<String>)
  - tags (Array<String>)
- Cache-Hinweis: im BP_GameDataSubsystem zusaetzlich Map "CharacterId -> InteractionProfile" bauen.

4) Struct FLootEntry (Sub-Struct)
- Felder:
  - item_id (String)
  - drop_chance (Float)

5) Struct FCurrencyReward (Sub-Struct)
- Felder:
  - currency_id (String)
  - amount (Float)
  - drop_chance (Float)

6) Struct FReputationReward (Sub-Struct)
- Felder:
  - faction_id (String)
  - amount (Float)
  - drop_chance (Float)

7) Struct FCompanionStatGrowth (Sub-Struct)
- Felder:
  - hp (Float)
  - attack (Float)
  - defense (Float)
  - speed (Float)
  - mana (Float)
  - spell_power (Float)

8) Struct FCompanionProgression (Sub-Struct)
- Felder:
  - level_cap (Integer)
  - xp_multiplier (Float)
  - stat_growth (Struct) -> FCompanionStatGrowth

9) Struct FCompanionConfig (Sub-Struct)
- Felder:
  - class_id (String)
  - level (Integer)
  - custom_abilities (Array<String>)
  - custom_stats (Map<String, Float>)
  - progression (Struct) -> FCompanionProgression

10) Struct FCombatProfileData (DataTable: combat_profiles)
- RowName: id (keine slug-Spalte vorhanden)
- Felder:
  - id (String)
  - character_id (String)
  - enemy_type (Enum/String) -> EEnemyType
  - aggression (Enum/String) -> EEnemyAggression
  - custom_stats (Map<String, Float>)
  - custom_abilities (Array<String>)
  - tags (Array<String>)
  - loot_table (Array<Struct>) -> FLootEntry
  - currency_rewards (Array<Struct>) -> FCurrencyReward
  - reputation_rewards (Array<Struct>) -> FReputationReward
  - xp_reward (Float)
  - related_quests (Array<String>)
  - companion_config (Struct) -> FCompanionConfig
- Cache-Hinweis: im BP_GameDataSubsystem zusaetzlich Map "CharacterId -> CombatProfile" bauen.

11) Struct FEncounterParticipant (Sub-Struct)
- Felder:
  - character_id (String)
  - contexts (Array<Enum/String>) -> EEncounterContext
  - combat_side (Enum/String) -> ECombatSide (optional)

12) Struct FEncounterData (DataTable: encounters)
- RowName: slug
- Felder:
  - id (String)
  - slug (String)
  - name (String)
  - description (Text)
  - encounter_type (Enum/String) -> EEncounterType
  - requirements_id (String)
  - participants (Array<Struct>) -> FEncounterParticipant
  - rewards (Struct) -> FEncounterReward (bestehend)
  - tags (Array<String>)

UE5 Checkliste (Character/Profile Block)
Ordner-Vorschlag:
- Enums: /Game/Data/Enums
- Structs: /Game/Data/Structs
- DataTables: /Game/Data/Tables
- Exports: /Game/Data/Exports

Phase 1: Enums anlegen (1:1 Strings aus Backend)
1) Lege Blueprint-Enum `EInteractionRole` an (/Game/Data/Enums)
   - Questgiver, Merchant, Trainer, Companion, Story, Background
2) Lege Blueprint-Enum `EEnemyType` an
   - beast, undead, humanoid, elemental, machine, boss, demon, dragon, giant, spirit, other
3) Lege Blueprint-Enum `EEnemyAggression` an
   - Hostile, Neutral, Friendly
4) Lege Blueprint-Enum `EEncounterContext` an
   - Combat, Interaction
5) Lege Blueprint-Enum `ECombatSide` an
   - Hostile, Friendly, Neutral

Phase 2: Structs anlegen (Reihenfolge wichtig)
1) Sub-Structs zuerst (sonst fehlen Typen)
   - FInteractionItemForSale
   - FLootEntry
   - FCurrencyReward
   - FReputationReward
   - FCompanionStatGrowth
   - FCompanionProgression
   - FCompanionConfig
   - FEncounterParticipant
2) Haupt-Structs danach
   - FCharacterData
   - FInteractionProfileData
   - FCombatProfileData
   - FEncounterData
3) Feldnamen exakt snake_case wie Export (z.B. character_id, combat_side)

Phase 3: DataTables importieren
1) Export aus SoA-Editor (CSV oder JSON)
2) Dateien nach /Game/Data/Exports kopieren
3) DataTables anlegen:
   - DT_Characters -> FCharacterData
   - DT_InteractionProfiles -> FInteractionProfileData
   - DT_CombatProfiles -> FCombatProfileData
   - DT_Encounters -> FEncounterData
4) Import/Reimport:
   - RowName = slug (nur bei Tabellen mit slug-Spalte)
   - RowName = id (bei combat_profiles, interaction_profiles)

Phase 4: Cache-Maps in BP_GameDataSubsystem
- Map_CharactersById (id -> FCharacterData)
- Map_CharactersBySlug (slug -> FCharacterData)
- Map_CombatProfileByCharacterId (character_id -> FCombatProfileData)
- Map_InteractionProfileByCharacterId (character_id -> FInteractionProfileData)
- Optional: Map_EncounterById/Slug fuer schnelle Lookups

Runtime-Wiring (wo die neuen Structs genutzt werden)
- BP_GameDataSubsystem: laedt DT_Characters, DT_CombatProfiles, DT_InteractionProfiles, DT_Encounters; baut die Maps oben.
- BP_EncounterDirector: fuer jeden Participant -> Character laden; bei Context Combat -> CombatProfile laden; combat_side steuert Team-Zuordnung; enemy_type/aggression/tags an AI weitergeben.
- BP_EnemyBrain: nutzt CombatProfile.tags + enemy_type/aggression fuer Verhalten und Targeting.
- BP_DialogueManager: nutzt FDialogueData.character_id -> Character fuer Namen/Portrait; InteractionProfile fuer Rollen/Flags.
- BP_ShopController/BP_ShopWidget: nutzt FShopData.character_id -> Character (Shopkeeper) und InteractionProfile (Inventory/Role).
- BP_CompanionManager: nutzt CombatProfile.companion_config + progression fuer Begleiter-Setup und Wachstum.

Typische Fehlerbilder (schnell pruefen)
- Enum-Mismatch: Import-Fehler, wenn Enum-Strings nicht exakt stimmen.
- RowName falsch: DataTable zeigt 0 Zeilen oder duplizierte Keys.
- JSON-Arrays nicht geparst: Pruefe, ob Export JSON-Arrays korrekt escaped sind.
- Leere Profile: Participant hat Combat-Context aber kein CombatProfile vorhanden.

[DONE]
Stats (Stat Data Table) - Quelle: backend/app/models/m_stats.py
Die Stat-Tabelle enthaelt alle numerischen Werte/Statusgroessen.
Struct FStatData (als Data Table importieren):
- Id (String) - ULID aus `id`, Originalwert fuer sichere Verknuepfungen.
- Slug (String) - sprechender Schluessel (`slug`), als Row Name nutzen.
- Name (String) - Anzeigename.
- Category (Enum/String) - `StatCategory` (Attribute, Combat, Defense, Magic, Support); Blueprint-Enum `EStatCategory` mit exakt gleichen Strings anlegen.
- Description (Text) - Beschreibung.
- ValueType (Enum/String) - `ValueType` (int, float, percentage); Blueprint-Enum `EStatValueType` mit identischen Strings anlegen.
- DefaultValue/MinValue/MaxValue (Float) - numerische Grenzen.
- ScalingBehavior (Enum/String) - None, Linear, Exponential, CustomCurve; Blueprint-Enum `EStatScalingBehavior` mit denselben DisplayNames hinterlegen.
- AppliesTo (Array<String>) - Einsatzbereiche; als `TArray<FString>` importieren.
- IconPath (String) - Asset-Referenz.
- Tags (Array<String>) - freie Schlagworte.

[DONE]
Attributes (Attribute Data Table) - Quelle: backend/app/models/m_attributes.py
Attribute sind Grundwerte, die auch Stat-Links besitzen.
Struct FAttributeData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name, Description (String/Text).
- ValueType (Enum/String) - `AttrValueType` (int, float); Blueprint-Enum `EAttributeValueType` mit exakt gleichen Namen.
- DefaultValue/MinValue/MaxValue (Float).
- Scaling (Enum/String) - None, Linear, Exponential, Logarithmic; Blueprint-Enum `EAttributeScaling` nach den Backend-Strings anlegen.
- UsedIn (Array<String>) - wo die Attribute verwendet werden.
- IconPath (String).
- Tags (Array<String>).

[DONE]
Attribute-Stat-Verknuepfung (Data Table fuer backend/app/models/m_attribute_stat_link.py)
Struct FAttributeStatLink (optional separate Data Table, falls benoetigt):
- Id (String) - ULID.
- AttributeId (String) - ULID des Attributes.
- StatId (String) - ULID des Stats.
- Scale (Enum/String) - Linear, Exponential, Custom; Blueprint-Enum `EAttributeStatScale` mit denselben Strings verwenden.
- Multiplier (Float) - Skalierungsfaktor.
Diese Tabelle erlaubt es, in UE5 blueprint-seitig alle Stat-Anpassungen pro Attribut zu iterieren.


Characters (Character Data Table) - Quelle: backend/app/models/m_characters.py
Struct FCharacterData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name (lesbar).
- name (String).
- title (String).
- description (Text).
- home_location_id (String) - ULID einer Location (optional).
- faction_id (String) - ULID einer Fraktion.
- class_id (String) - ULID einer CharacterClass (optional).
- level (Integer).
- image_path (String).
- tags (Array<String>).

Interaction Profiles (Interaction Profile Data Table) - Quelle: backend/app/models/m_interaction_profiles.py
Struct FInteractionProfileData:
- RowName: id
- id (String) - ULID.
- character_id (String) - ULID eines Characters.
- role (Enum/String) - `InteractionRole` (Questgiver, Merchant, Trainer, Companion, Story, Background); Blueprint-Enum `EInteractionRole` exakt nach diesen Bezeichnungen erstellen.
- dialogue_tree_id (String) - ULID eines Dialogs.
- available_quests (Array<String>) - Quest-ULIDs.
- inventory (Array<Struct>) - JSON aus { item_id, price }; in UE5 als `TArray<FInteractionItemForSale>` abbilden.
- flags_set_on_interaction (Array<String>) - Flag-ULIDs.
- tags (Array<String>).

Struct FInteractionItemForSale:
- item_id (String).
- price (Float).

Dialoge (Dialogue Data Table) - Quelle: backend/app/models/m_dialogues.py
Struct FDialogueData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- title (String) - interner Titel.
- character_id (String) - ULID eines Characters.
- location_id (String) - ULID einer Location.
- requirements_id (String) - ULID eines Requirement-Satzes.
- description (Text) - Notizen fuer Autoren.
- tags (Array<String>) - Stichwoerter.
Diese Tabelle bildet die Uebersicht aller Dialogfluesse ab; einzelne Knoten folgen in einer separaten Data Table.

Dialogknoten (Dialogue Node Data Table) - Quelle: backend/app/models/m_dialogue_nodes.py
Struct FDialogueNodeData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- dialogue_id (String) - ULID des uebergeordneten Dialogs.
- speaker (String) - Sprecher-Kennung (z.B. Character- oder Player-Slug).
- text (Text) - angezeigter Dialogtext.
- requirements_id (String) - ULID eines Requirement-Satzes (optional).
- choices (Array<Struct>) - Liste von Antwortoptionen { choice_text, next_node_id, requirements_id, flags_set }.
- set_flags (Array<String>) - Flags, die dieser Knoten setzt.
- tags (Array<String>).
In UE5 koennen Choices als eigener Struct `FDialogueChoice` modelliert werden.

Items (Item Data Table) - Quelle: backend/app/models/m_items.py
Struct FItemData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Type (Enum/String) - `ItemType` (Weapon, Armor, Consumable, Misc); Blueprint-Enum `EItemType` mit identischen Strings anlegen.
- Rarity (Enum/String) - Common, Uncommon, Rare, Epic, Legendary; Blueprint-Enum `EItemRarity` verwenden.
- Description (Text).
- EquipmentSlot (Enum/String) - head, chest, legs, feet, main_hand, off_hand, accessory; Blueprint-Enum `EEquipmentSlot` exakt nach diesen Keys definieren.
- WeaponType (Enum/String) - Sword, Axe, Bow, Staff, Dagger, Mace; Blueprint-Enum `EWeaponType` mit gleichen Strings.
- StatDamage/StatDefense/StatCritChance/StatWeight (Float).
- AttrStrength/AttrDexterity/AttrVitality/AttrIntelligence (Float) - Attributboni.
- Effects (Array<String>) - Effekt-ULIDs.
- Tags (Array<String>).
- IconPath (String).
- RequirementsId (String) - ULID eines Requirement-Eintrags; optional Data Table `FRequirementData` nutzen.

Abilities (Ability Data Table) - Quelle: backend/app/models/m_abilities.py
Struct FAbilityData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Type (Enum/String) - Active, Passive, Toggle; Blueprint-Enum `EAbilityType` exakt nach Backend-Strings.
- IconPath (String).
- Description (Text).
- ResourceCost (Float).
- Cooldown (Float).
- Targeting (Enum/String) - Single, Area, Self, Allies, Enemies; Blueprint-Enum `EAbilityTargeting` mit denselben Namen.
- TriggerCondition (Enum/String) - OnUse, Passive, OnHit, WhenDamaged, OnKill; Blueprint-Enum `EAbilityTrigger` verwenden.
- Requirements (Text/JSON) - als Raw JSON-String importieren oder in ein Struct parsen.
- Tags (Array<String>).

Ability-Effekt-Verknuepfung - backend/app/models/m_abilities_links.py
Struct FAbilityEffectLink:
- Id (String) - ULID.
- AbilityId (String) - ULID der Ability.
- EffectId (String) - ULID des Effekts.
Damit lassen sich in Blueprint alle Effekte einer Faehigkeit via ULID nachladen.

Ability-Scaling-Verknuepfung
Struct FAbilityScalingLink:
- Id (String) - ULID.
- AbilityId (String).
- AttributeId (String).
- Multiplier (Float) - Faktor fuer die Skalierung.
Optional kann ein Blueprint-Struct `FAbilityScaling` direkt in `FAbilityData` eingebettet werden, falls der Export die Arrays bereits expandiert.

Effects (Effect Data Table) - Quelle: backend/app/models/m_effects.py
Struct FEffectData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Type (Enum/String) - Status, Damage, Heal, Modifier, Reflect, Summon, Shield, Control; Blueprint-Enum `EEffectType` exakt uebernehmen.
- Description (Text).
- Target (Enum/String) - Self, Enemy, Ally, All, Area; Blueprint-Enum `EEffectTarget` mit gleichen Strings.
- Duration (Float).
- ValueType (Enum/String) - Flat, Percentage, None; Blueprint-Enum `EEffectValueType` mit identischen Namen.
- Value (Float).
- AttributeId (String) - optionale ULID eines Attributes.
- ScalingStatId (String) - optionale ULID eines Stats.
- TriggerCondition (Enum/String) - None, OnHit, WhenDamaged, OnKill, OnCast, Passive; Blueprint-Enum `EEffectTriggerCondition` anlegen.
- Stackable (Boolean).
- SetBonusGroup (String).
- IconPath (String).
- RelatedItems (Array<String>) - Item-ULIDs.
- Tags (Array<String>).

Combat Profiles (Combat Profile Data Table) - Quelle: backend/app/models/m_combat_profiles.py
Struct FCombatProfileData:
- RowName: id
- id (String) - ULID.
- character_id (String) - ULID eines Characters.
- enemy_type (Enum/String) - beast, undead, humanoid, elemental, machine, boss, demon, dragon, giant, spirit, other; Blueprint-Enum `EEnemyType` exakt wie im Backend.
- aggression (Enum/String) - Hostile, Neutral, Friendly; Blueprint-Enum `EEnemyAggression` verwenden.
- custom_stats (Map<String, Float>) - individuelle Stat-Overrides.
- custom_abilities (Array<String>) - Ability-ULIDs.
- tags (Array<String>).
- loot_table (Array<Struct>) - { item_id, drop_chance } als `TArray<FLootEntry>`.
- currency_rewards (Array<Struct>) - { currency_id, amount, drop_chance }.
- reputation_rewards (Array<Struct>) - { faction_id, amount, drop_chance }.
- xp_reward (Float).
- related_quests (Array<String>) - Quest-ULIDs.
- companion_config (Struct/JSON) - optionale Overrides + Progression fuer Begleiter.

Struct FLootEntry:
- item_id (String).
- drop_chance (Float).

Struct FCurrencyReward:
- currency_id (String).
- amount (Float).
- drop_chance (Float).

Struct FReputationReward:
- faction_id (String).
- amount (Float).
- drop_chance (Float).

Struct FCompanionConfig:
- class_id (String) - optionaler Override fuer Combat Class.
- level (Integer) - optionaler Override fuer Startlevel.
- custom_abilities (Array<String>).
- custom_stats (Map<String, Float>).
- progression (Struct) - siehe FCompanionProgression.

Struct FCompanionProgression:
- level_cap (Integer).
- xp_multiplier (Float).
- stat_growth (Struct) - siehe FCompanionStatGrowth.

Struct FCompanionStatGrowth:
- hp (Float).
- attack (Float).
- defense (Float).
- speed (Float).
- mana (Float).
- spell_power (Float).

Encounters (Encounter Data Table) - Quelle: backend/app/models/m_encounters.py
Struct FEncounterData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- encounter_type (Enum/String) - Combat, Dialogue, Event; Blueprint-Enum `EEncounterType` mit identischen Strings.
- requirements_id (String) - ULID eines Requirement-Satzes.
- participants (Array<Struct>) - { character_id, contexts, combat_side }.
- rewards (Struct/JSON) - { xp, items, currencies, reputation, flags_set } als `FEncounterReward`.
- tags (Array<String>).

Struct FEncounterParticipant:
- character_id (String).
- contexts (Array<Enum/String>) - Combat, Interaction; Blueprint-Enum `EEncounterContext` mit exakt gleichen Strings.
- combat_side (Enum/String) - Hostile, Friendly, Neutral; optional, Blueprint-Enum `ECombatSide`.

Events (Event Data Table) - Quelle: backend/app/models/m_events.py
Struct FEventData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Title (String).
- Type (Enum/String) - Encounter, ItemReward, LoreDiscovery, Dialogue, Teleport, ScriptedScene; Blueprint-Enum `EEventType` exakt nach Backend.
- RequirementsId (String) - ULID eines Requirement-Satzes.
- LocationId (String) - ULID einer Location.
- LoreId (String) - ULID eines Lore-Eintrags.
- DialogueId (String) - ULID eines Dialogs.
- EncounterId (String) - ULID eines Encounters.
- ItemRewards (Array<Struct>) - { item_id, quantity }.
- XpReward (Float).
- CurrencyRewards (Array<Struct>) - { currency_id, amount }.
- ReputationRewards (Array<Struct>) - { faction_id, amount }.
- FlagsSet (Array<String>) - Flag-ULIDs.
- Tags (Array<String>).
- NextEventId (String) - ULID fuer Ketten-Logik.

Factions (Faction Data Table) - Quelle: backend/app/models/m_factions.py
Struct FFactionData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Description (Text).
- Alignment (Enum/String) - Hostile, Neutral, Friendly; Blueprint-Enum `EFactionAlignment` mit identischen Strings.
- Relationships (Map<String, String>) - Zuordnung anderer Fraktionen zu Einstufungen.
- ReputationConfig (Struct/JSON) - Grenzwerte fuer Rufstufen; als `FFactionReputationConfig` modellieren.
- Tags (Array<String>).
- IconPath (String).

Flags (Flag Data Table) - Quelle: backend/app/models/m_flags.py
Struct FFlagData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Description (Text).
- FlagType (Enum/String) - Story Progress, Quest State, Lore Discovery, Item Unlock, NPC Relationship, Companion Progress, Secret Discovery, Shop Unlock, Event Trigger, Other; Blueprint-Enum `EFlagType` mit exakt diesen Strings.
- DefaultValue (Boolean).
- ContentPack (Enum/String) - Base, DLC1, DLC2, Expansion; Blueprint-Enum `EContentPack` identisch anlegen.
- Tags (Array<String>).

Locations (Location Data Table) - Quelle: backend/app/models/m_locations.py
Struct FLocationData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Description (Text).
- Biome (Enum/String) - Plains, Forest, Cave, Mountain, Desert, Swamp, Coast, Tundra, City, Ruins, Fortress, Sky Isles, Cloud Sea, Crystal Caverns, Magma Veins, Fungal Undergrowth, Abyss; Blueprint-Enum `ELocationBiome` mit denselben Namen.
- BiomeModifier (Enum/String, optional) - Arcane, Corrupted, Divine, Shadowed, Dreamlike; Blueprint-Enum `ELocationBiomeModifier` ebenfalls exakt benennen.
- Region (String) - freie Regionseinteilung.
- LevelRange (Struct/JSON) - { Min, Max } als `FLevelRange`.
- Coordinates (Struct/JSON) - { X, Y } fuer Karte oder Editor.
- ImagePath (String).
- Encounters (Array<String>) - Encounter-ULIDs.
- IsSafeZone (Boolean).
- IsFastTravelPoint (Boolean).
- HasRespawnPoint (Boolean).
- Tags (Array<String>).

Location Routes (LocationRoute Data Table) - neue Export-Tabelle fuer das Reisesystem
Struct FLocationRouteData:
- Id (String) - ULID.
- Slug (String) - Row Name (z.B. `northpass_to_highridge`).
- FromLocationId (String) - ULID der Quell-Location.
- ToLocationId (String) - ULID der Ziel-Location.
- TravelTime (Float) - Dauer in Spielstunden/-tagen.
- Distance (Float) - Distanz oder Abstraktion fuer UI.
- RequirementsId (String) - ULID eines Requirement-Satzes (Blockaden, Ruf, Story).
- EncounterWeightModifier (Float) - Multiplikator fuer Zufallsbegegnungen auf dieser Route.
- CostCurrencyId (String, optional) - ULID einer Waehrung fuer Reisekosten.
- CostAmount (Float, optional) - Kostenbetrag.
- FlagsUnlock (Array<String>) - Flag-ULIDs, die beim Freischalten gesetzt werden.
- FlagsLock (Array<String>) - Flag-ULIDs, bei deren Setzen die Route gesperrt wird.
- IsBidirectional (Boolean) - true, wenn dieselben Werte fuer Hin- und Rueckweg gelten; ansonsten zweite Zeile anlegen.
- Tags (Array<String>) - Zusaetzliche Metadaten (z.B. `MountainPass`, `RequiresAirship`).
Diese Tabelle ermoeglicht den Aufbau eines Graphen in UE5 (`BP_WorldGraphSubsystem`) und spiegelt die neuen Reise-Workflows aus dem Plan wider.

Lore (Lore Entry Data Table) - Quelle: backend/app/models/m_lore_entries.py
Struct FLoreEntryData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Title (String).
- Text (Text).
- LocationId (String) - ULID einer Location.
- TimelineId (String) - ULID einer Timeline.
- RelatedStoryArcs (Array<String>) - Story-Arc-ULIDs.
- Tags (Array<String>).

Quests (Quest Data Table) - Quelle: backend/app/models/m_quests.py
Struct FQuestData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Title (String).
- Description (Text).
- StoryArcId (String) - ULID eines Story-Arcs.
- RequirementsId (String) - ULID eines Requirement-Satzes.
- Objectives (Array<Struct>) - { ObjectiveId, Description, RequirementsId, FlagsSet }.
- FlagsSetOnCompletion (Array<String>) - Flag-ULIDs.
- XpReward (Float).
- CurrencyRewards (Array<Struct>) - { currency_id, amount }.
- ReputationRewards (Array<Struct>) - { faction_id, amount }.
- ItemRewards (Array<Struct>) - { item_id, quantity }.
- Tags (Array<String>).

Story Arcs (Story Arc Data Table) - Quelle: backend/app/models/m_story_arcs.py
Struct FStoryArcData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Title (String).
- Summary (Text).
- Type (Enum/String) - Main Story, Side Arc, Faction Arc, DLC Arc; Blueprint-Enum `EStoryArcType` exakt uebernehmen.
- ContentPack (Enum/String) - Base, DLC1, DLC2, Expansion; Blueprint-Enum `EContentPack` weiterverwenden.
- TimelineId (String) - ULID einer Timeline.
- RelatedQuests (Array<String>) - Quest-ULIDs.
- Branching (Array<Struct>) - { QuestId, Branches: [{ FlagId, NextQuestId }] }.
- RequiredFlags (Array<String>) - Flag-ULIDs.
- Tags (Array<String>).

Timelines (Timeline Data Table) - Quelle: backend/app/models/m_timelines.py
Struct FTimelineData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Description (Text).
- StartYear (Integer).
- EndYear (Integer).
- Tags (Array<String>).

Character Classes (Class Data Table) - Quelle: backend/app/models/m_characterclasses.py
Struct FCharacterClassData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Description (Text).
- Role (Enum/String) - Tank, Damage, Healer, Support, Hybrid; Blueprint-Enum `ECharacterRole` mit denselben Strings.
- BaseStats (Map<String, Float>) - Startwerte.
- StatGrowth (Map<String, Float>) - Zuwachse pro Level.
- StartingAbilities (Array<String>) - Ability-ULIDs.
- PreferredAttributes (Array<String>) - Attribute-ULIDs.
- StartingEquipment (Array<String>) - Item-ULIDs.
- Tags (Array<String>).

Shops (Shop Data Table) - Quelle: backend/app/models/m_shops.py
Struct FShopData:
- Id (String) - ULID.
- Slug (String) - Row Name.
- Name (String).
- Description (Text).
- LocationId (String) - ULID einer Location.
- CharacterId (String) - ULID eines Characters (optional, wenn Shop an Character haengt).
- RequirementsId (String) - ULID eines Requirement-Datensatzes.
- PriceModifiers (Map/String) - JSON fuer Rabatte/Aufschlaege; als `TMap<FString, float>` oder Raw JSON importieren.
- Tags (Array<String>).

Shop-Inventory (ShopInventory Data Table) - Quelle: backend/app/models/m_shop_inventory.py
Struct FShopInventoryItem:
- Id (String) - ULID.
- Slug (String) - Row Name (z.B. Kombination aus Shop und Item).
- ShopId (String) - ULID des Shops.
- ItemId (String) - ULID des Items.
- Price (Float).
- Stock (Integer) - `-1` oder leer = unbegrenzt.
- RequirementsId (String) - ULID eines Requirement-Eintrags.
- Tags (Array<String>).

Requirements (Requirement Data Table) - Quelle: backend/app/models/m_requirements.py
Struct FRequirementData (optional):
- Id (String) - ULID.
- Slug (String) - Row Name.
- Tags (Array<String>).
Dazu optionale Link-Tabellen als separate Data Tables, falls im Spiel benoetigt:
- RequirementRequiredFlag: Id, RequirementId, FlagId.
- RequirementForbiddenFlag: Id, RequirementId, FlagId.
- RequirementMinFactionReputation: Id, RequirementId, FactionId, MinValue.

Import- und Blueprint-Hinweise
- Arrays/Maps aus JSON lassen sich mit JSON-Data-Table-Import direkt nach UE5 holen. Alternativ CSV-Exports erzeugen, bei denen Array-Felder als `[]`-Schreibweise (JSON) bleiben; UE5 parst diese in `TArray`/`TMap`, wenn die Struct entsprechend definiert ist.
- Fuer alle Enum-Felder lohnt sich ein Blueprint-Enum, dessen Display-Namen exakt den Strings aus den Modellen entsprechen. So verhindert ihr Tippfehler nach dem Import.
- ULIDs bleiben als `FString`. Bei haeufiger Nutzung kann zusaetzlich ein `FName`-Feld (z.B. `IdName`) in der Struct befuellt werden, das per Blueprint in `PreConstruct` gesetzt wird (`Conv_StringToName`), damit Data-Table-Lookups schneller funktionieren.
- Querverweise (z.B. Ability -> Effects, Item -> Requirements, Event -> Encounter) sollten im Blueprint-Code via Helper-Funktionen geloest werden, die ueber die Data Tables anhand der ULID-Strings nachschlagen und bei fehlenden Eintraegen Warnungen ausgeben. Dadurch bleibt der Datenfluss identisch zum Backend.
- Editor-Workflows: Nach einem Export aus dem SoA-Editor CSV/JSON-Dateien in `Content/Data/Exports` legen, `Structs` aktualisieren und `Reimport` auf der jeweiligen Data Table ausfuehren. Prueft die Output-Log auf Fehlermeldungen zu fehlenden Zeilennamen (haeufig Zeichenketten, die nicht exakt mit ULID oder Slug uebereinstimmen).

Mit diesen Structs und Data Tables steht in UE5 eine vollstaendige 1:1-Abbildung der SoA-Datenmodelle bereit. Designers koennen die Inhalte datengetrieben anpassen, waehrend Blueprints ueber stabile ULID-Verknuepfungen und Slugs als lesbare Schluessel auf alle Werte zugreifen.
