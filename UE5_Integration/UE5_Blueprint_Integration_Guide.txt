Uebersicht: Datenstrukturen und Data Tables fuer Unreal Engine 5
Um die im SoA-Editor gepflegten Inhalte in Unreal Engine 5 zu verwenden, sollten fuer jede Datenkategorie passende Blueprint-Structs und Data Tables erstellt werden. Alle Kernmodelle im Repository nutzen ULIDs als primaerschluessel (`id`) und zusaetzlich sprechende Slugs (`slug`). In UE5 empfiehlt es sich, den `slug` als Row Name zu verwenden (gut lesbar), den ULID-String aber als eigenes Feld in der Struct zu speichern, damit Querverweise stabil bleiben. Importiert wird bevorzugt ueber CSV- oder JSON-Exports, die Feldnamen muessen exakt mit den Struct-Feldern uebereinstimmen. Alle Loesungen bleiben blueprint-only; optionale Enums lassen sich als Blueprint-Enums abbilden, um die Editor-Bedienung zu vereinfachen. Alle Blueprint-Enums muessen die Backend-Strings unveraendert uebernehmen, damit CSV/JSON-Importe fehlerfrei greifen.

Arbeitsmodus: "Heute zu tun" Checkliste (damit klar ist, wo du stehst)
1) Ein Systemblock auswaehlen (z.B. Stats/Attributes oder Dialogue).
2) Fuer den Block: Blueprint-Enums anlegen und Strings 1:1 uebernehmen.
3) Struct(s) anlegen und Felder exakt wie Export benennen.
4) DataTable erstellen und Import testen (1-2 Beispielzeilen).
5) Validation-Notiz: Welche IDs verlinken auf andere Tabellen?
6) Im BP_GameDataSubsystem: Cache-Map fuer diesen Block anlegen.
7) Ergebnis markieren: "Block X fertig importiert + gecacht".

Runtime-Architektur (Lyra-inspiriert, Blueprint-only, ohne GAS)
- DataTables sind Import-Quelle, nicht die Runtime-Datenbank.
- Beim Spielstart: DataTables in Registry-Maps cachen (ULID -> Struct, Slug -> Struct).
- Kommunikation ueber Message-Events statt direkte Manager-Aufrufe (entkoppelt).
- SoftObjectReferences fuer Assets (Icons, Portraits, VO) statt harter Pfad-Strings, wo moeglich.

Konkrete Runtime-Bausteine
- BP_GameDataSubsystem: laedt DataTables, baut Cache-Maps, bietet Lookup-Funktionen.
- BP_MessageHub (oder Gameplay Message Subsystem): Events wie FlagChanged, QuestAdvanced, RewardApplied.
- BP_FlagManager/BP_QuestLog: verwalten Zustand, senden Events, reagieren auf Events.

Import-Workflow (Schritt-fuer-Schritt, wiederholbar)
1) Export aus SoA-Editor (CSV oder JSON).
2) Dateien nach `Content/Data/Exports` kopieren.
3) Blueprint-Enum(s) aktualisieren oder neu erstellen.
4) Struct(s) pruefen: Feldnamen = Export-Spalten.
5) DataTable importieren oder reimportieren.
6) BP_DataImportManager laufen lassen (Validation: fehlende ULIDs, Enum-Mismatch).
7) BP_GameDataSubsystem neu laden, Cache-Maps aktualisieren.
8) Ergebnis notieren: "Import OK" oder "Fehlerliste".

Kommunikationsregeln (damit Systeme nicht verdrahtet sind)
- Keine direkte Manager-zu-Manager-Calls fuer Gameplay-Flows.
- Events senden: FlagChanged, RequirementPassed, QuestCompleted, RewardGranted.
- Listener entscheiden lokal, was sie tun (UI refresh, Inventory update, Story advance).

Empfohlene Reihenfolge fuer Structs + Imports (MVP zuerst)
1) Core: Stats, Attributes, AttributeStatLink
2) Progression: CharacterClasses, Items, Item Stat/Attribute Modifiers
3) Narrative Spine: Flags, Requirements + Link-Tabellen, Quests, StoryArcs, Dialogues, DialogueNodes
4) World: Locations, Characters, Factions, Encounters, Events, Lore, Timelines
5) Combat: Abilities, Ability Links, Effects, Combat Profiles
6) Economy: Currencies, Shops, ShopInventory

Enum-Index (Blueprint-Enums, 1:1 Backend-Strings)
- EInteractionRole: Questgiver, Merchant, Trainer, Companion, Story, Background
- EEnemyType: beast, undead, humanoid, elemental, machine, boss, demon, dragon, giant, spirit, emanation, other
- EEnemyAggression: Hostile, Neutral, Friendly
- EEncounterContext: Combat, Interaction
- ECombatSide: Hostile, Friendly, Neutral
- EEncounterType: Combat, Dialogue, Event
- EStatCategory: Attribute, Combat, Defense, Magic, Support
- EStatValueType: int, float, percentage
- EStatScalingBehavior: None, Linear, Exponential, Custom Curve
- EAttributeValueType: int, float
- EAttributeScaling: None, Linear, Exponential, Logarithmic
- EAttributeStatScale: Linear, Exponential, Custom
- EItemType: Weapon, Armor, Accessory, Consumable, Tool, Material, Upgrade, Quest, SetPiece, Misc
- EItemRarity: Common, Uncommon, Rare, Epic, Legendary
- EEquipmentSlot: head, chest, legs, feet, hands, belt, ring, amulet, back, main_hand, off_hand, two_hand, accessory, mount, pet
- EWeaponType: Greatsword, Longsword, Shortsword, Dagger, Rapier, Axe, Greataxe, Hammer, Mace, Spear, Polearm, Halberd, Staff, Wand, Tome, Bow, Crossbow, Firearm, Thrown, Unarmed, Shield, Focus, Instrument
- EDamageType: Slashing, Piercing, Blunt, Elemental, Poison, Psychic, Light, Shadow
- EWeaponRangeType: melee, range
- EModifierValueType: Flat, Percentage, Multiplier
- EAbilityType: Active, Passive, Toggle
- EAbilityTargeting: Single, Area, Self, Allies, Enemies
- EAbilityTrigger: On Use, Passive, On Hit, When Damaged, On Kill
- EEffectType: Status, Damage, Heal, Modifier, Reflect, Summon, Shield, Control
- EEffectTarget: Self, Enemy, Ally, All, Area
- EEffectValueType: Flat, Percentage, None
- EEffectTriggerCondition: None, On Hit, When Damaged, On Kill, On Cast, Passive
- EEventType: Encounter, ItemReward, LoreDiscovery, Dialogue, Teleport, ScriptedScene
- EFactionAlignment: Hostile, Neutral, Friendly
- EFlagType: Story Progress, Quest State, Lore Discovery, Item Unlock, NPC Relationship, Companion Progress, Secret Discovery, Shop Unlock, Event Trigger, Other
- ELocationBiome: Plains, Forest, Cave, Mountain, Desert, Swamp, Coast, Tundra, City, Ruins, Fortress, Sky Isles, Cloud Sea, Crystal Caverns, Magma Veins, Fungal Undergrowth, Abyss
- ELocationBiomeModifier: Arcane, Corrupted, Divine, Shadowed, Dreamlike
- EStoryArcType: Main Story, Side Arc, Faction Arc, DLC Arc
- ECharacterRole: Tank, Damage, Healer, Support, Hybrid
- ECurrencyType: Soft, Premium, Token

Character/Profile Umbau - Start jetzt (Enums zuerst, dann Structs)
Enums (Phase 1 - zuerst anlegen, Strings 1:1 wie Backend):
- EInteractionRole: Questgiver, Merchant, Trainer, Companion, Story, Background
- EEnemyType: beast, undead, humanoid, elemental, machine, boss, demon, dragon, giant, spirit, emanation, other
- EEnemyAggression: Hostile, Neutral, Friendly
- EEncounterContext: Combat, Interaction
- ECombatSide: Hostile, Friendly, Neutral

Structs (Phase 2 - danach anlegen, Details siehe unten):
- FCharacterData
- FInteractionProfileData (+ FInteractionItemForSale)
- FCombatProfileData (+ FLootEntry, FCurrencyReward, FReputationReward, FCompanionConfig, FCompanionProgression, FCompanionStatGrowth)
- FEncounterParticipant (in FEncounterData)

Blueprint-To-Do (Character/Profile Block, Schritt fuer Schritt)
Hinweis: Feldnamen in Structs muessen exakt den Export-Spalten entsprechen (snake_case). RowName nutzt slug, wenn vorhanden; bei Profilen ohne slug RowName = id.

1) Struct FCharacterData (DataTable: characters)
- RowName: slug (aus Export-Spalte "slug")
- Felder:
  - id (String)
  - slug (String)
  - name (String)
  - title (String)
  - description (Text)
  - home_location_id (String)
  - faction_id (String)
  - class_id (String)
  - level (Integer)
  - image_path (String)
  - tags (Array<String>)

2) Struct FInteractionItemForSale (Sub-Struct)
- Felder:
  - item_id (String)
  - price (Float)

3) Struct FInteractionProfileData (DataTable: interaction_profiles)
- RowName: id (keine slug-Spalte vorhanden)
- Felder:
  - id (String)
  - character_id (String)
  - role (Enum/String) -> EInteractionRole
  - dialogue_tree_id (String)
  - available_quests (Array<String>)
  - inventory (Array<Struct>) -> FInteractionItemForSale
  - flags_set_on_interaction (Array<String>)
  - tags (Array<String>)
- Cache-Hinweis: im BP_GameDataSubsystem zusaetzlich Map "CharacterId -> InteractionProfile" bauen.

4) Struct FLootEntry (Sub-Struct)
- Felder:
  - item_id (String)
  - drop_chance (Float)

5) Struct FCurrencyReward (Sub-Struct)
- Felder:
  - currency_id (String)
  - amount (Float)
  - drop_chance (Float)

6) Struct FReputationReward (Sub-Struct)
- Felder:
  - faction_id (String)
  - amount (Float)
  - drop_chance (Float)

7) Struct FCompanionStatGrowth (Sub-Struct)
- Felder:
  - hp (Float)
  - attack (Float)
  - defense (Float)
  - speed (Float)
  - mana (Float)
  - spell_power (Float)

8) Struct FCompanionProgression (Sub-Struct)
- Felder:
  - level_cap (Integer)
  - xp_multiplier (Float)
  - stat_growth (Struct) -> FCompanionStatGrowth

9) Struct FCompanionConfig (Sub-Struct)
- Felder:
  - class_id (String)
  - level (Integer)
  - custom_abilities (Array<String>)
  - custom_stats (Map<String, Float>)
  - progression (Struct) -> FCompanionProgression

10) Struct FCombatProfileData (DataTable: combat_profiles)
- RowName: id (keine slug-Spalte vorhanden)
- Felder:
  - id (String)
  - character_id (String)
  - enemy_type (Enum/String) -> EEnemyType
  - aggression (Enum/String) -> EEnemyAggression
  - custom_stats (Map<String, Float>)
  - custom_abilities (Array<String>)
  - tags (Array<String>)
  - loot_table (Array<Struct>) -> FLootEntry
  - currency_rewards (Array<Struct>) -> FCurrencyReward
  - reputation_rewards (Array<Struct>) -> FReputationReward
  - xp_reward (Float)
  - related_quests (Array<String>)
  - companion_config (Struct) -> FCompanionConfig
- Cache-Hinweis: im BP_GameDataSubsystem zusaetzlich Map "CharacterId -> CombatProfile" bauen.

11) Struct FEncounterParticipant (Sub-Struct)
- Felder:
  - character_id (String)
  - contexts (Array<Enum/String>) -> EEncounterContext
  - combat_side (Enum/String) -> ECombatSide (optional)

12) Struct FEncounterData (DataTable: encounters)
- RowName: slug
- Felder:
  - id (String)
  - slug (String)
  - name (String)
  - description (Text)
  - encounter_type (Enum/String) -> EEncounterType
  - requirements_id (String)
  - participants (Array<Struct>) -> FEncounterParticipant
  - rewards (Struct) -> FEncounterReward (bestehend)
  - tags (Array<String>)

UE5 Checkliste (Character/Profile Block)
Ordner-Vorschlag:
- Enums: /Game/Data/Enums
- Structs: /Game/Data/Structs
- DataTables: /Game/Data/Tables
- Exports: /Game/Data/Exports

Phase 1: Enums anlegen (1:1 Strings aus Backend)
1) Lege Blueprint-Enum `EInteractionRole` an (/Game/Data/Enums)
   - Questgiver, Merchant, Trainer, Companion, Story, Background
2) Lege Blueprint-Enum `EEnemyType` an
   - beast, undead, humanoid, elemental, machine, boss, demon, dragon, giant, spirit, other
3) Lege Blueprint-Enum `EEnemyAggression` an
   - Hostile, Neutral, Friendly
4) Lege Blueprint-Enum `EEncounterContext` an
   - Combat, Interaction
5) Lege Blueprint-Enum `ECombatSide` an
   - Hostile, Friendly, Neutral

Phase 2: Structs anlegen (Reihenfolge wichtig)
1) Sub-Structs zuerst (sonst fehlen Typen)
   - FInteractionItemForSale
   - FLootEntry
   - FCurrencyReward
   - FReputationReward
   - FCompanionStatGrowth
   - FCompanionProgression
   - FCompanionConfig
   - FEncounterParticipant
2) Haupt-Structs danach
   - FCharacterData
   - FInteractionProfileData
   - FCombatProfileData
   - FEncounterData
3) Feldnamen exakt snake_case wie Export (z.B. character_id, combat_side)

Phase 3: DataTables importieren
1) Export aus SoA-Editor (CSV oder JSON)
2) Dateien nach /Game/Data/Exports kopieren
3) DataTables anlegen:
   - DT_Characters -> FCharacterData
   - DT_InteractionProfiles -> FInteractionProfileData
   - DT_CombatProfiles -> FCombatProfileData
   - DT_Encounters -> FEncounterData
4) Import/Reimport:
   - RowName = slug (nur bei Tabellen mit slug-Spalte)
   - RowName = id (bei combat_profiles, interaction_profiles)

Phase 4: Cache-Maps in BP_GameDataSubsystem
- Map_CharactersById (id -> FCharacterData)
- Map_CharactersBySlug (slug -> FCharacterData)
- Map_CombatProfileByCharacterId (character_id -> FCombatProfileData)
- Map_InteractionProfileByCharacterId (character_id -> FInteractionProfileData)
- Optional: Map_EncounterById/Slug fuer schnelle Lookups

Runtime-Wiring (wo die neuen Structs genutzt werden)
- BP_GameDataSubsystem: laedt DT_Characters, DT_CombatProfiles, DT_InteractionProfiles, DT_Encounters; baut die Maps oben.
- BP_EncounterDirector: fuer jeden Participant -> Character laden; bei Context Combat -> CombatProfile laden; combat_side steuert Team-Zuordnung; enemy_type/aggression/tags an AI weitergeben.
- BP_EnemyBrain: nutzt CombatProfile.tags + enemy_type/aggression fuer Verhalten und Targeting.
- BP_DialogueManager: nutzt FDialogueData.character_id -> Character fuer Namen/Portrait; InteractionProfile fuer Rollen/Flags.
- BP_ShopController/BP_ShopWidget: nutzt FShopData.character_id -> Character (Shopkeeper) und InteractionProfile (Inventory/Role).
- BP_CompanionManager: nutzt CombatProfile.companion_config + progression fuer Begleiter-Setup und Wachstum.

Typische Fehlerbilder (schnell pruefen)
- Enum-Mismatch: Import-Fehler, wenn Enum-Strings nicht exakt stimmen.
- RowName falsch: DataTable zeigt 0 Zeilen oder duplizierte Keys.
- JSON-Arrays nicht geparst: Pruefe, ob Export JSON-Arrays korrekt escaped sind.
- Leere Profile: Participant hat Combat-Context aber kein CombatProfile vorhanden.

[DONE]
Stats (Stat Data Table) - Quelle: backend/app/models/m_stats.py
Die Stat-Tabelle enthaelt alle numerischen Werte/Statusgroessen.
Struct FStatData (als Data Table importieren):
- RowName: slug
- id (String) - ULID aus `id`, Originalwert fuer sichere Verknuepfungen.
- slug (String) - sprechender Schluessel (`slug`), als Row Name nutzen.
- name (String) - Anzeigename.
- category (Enum/String) - `StatCategory` (Attribute, Combat, Defense, Magic, Support); Blueprint-Enum `EStatCategory` mit exakt gleichen Strings anlegen.
- description (Text) - Beschreibung.
- value_type (Enum/String) - `ValueType` (int, float, percentage); Blueprint-Enum `EStatValueType` mit identischen Strings anlegen.
- default_value (Float) - numerische Grenze.
- min_value (Float) - numerische Grenze.
- max_value (Float) - numerische Grenze.
- scaling_behavior (Enum/String) - None, Linear, Exponential, CustomCurve; Blueprint-Enum `EStatScalingBehavior` mit denselben DisplayNames hinterlegen.
- applies_to (Array<String>) - Einsatzbereiche; als `TArray<FString>` importieren.
- icon_path (String) - Asset-Referenz.
- tags (Array<String>) - freie Schlagworte.

[DONE]
Attributes (Attribute Data Table) - Quelle: backend/app/models/m_attributes.py
Attribute sind Grundwerte, die auch Stat-Links besitzen.
Struct FAttributeData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- value_type (Enum/String) - `AttrValueType` (int, float); Blueprint-Enum `EAttributeValueType` mit exakt gleichen Namen.
- default_value (Float).
- min_value (Float).
- max_value (Float).
- scaling (Enum/String) - None, Linear, Exponential, Logarithmic; Blueprint-Enum `EAttributeScaling` nach den Backend-Strings anlegen.
- used_in (Array<String>) - wo die Attribute verwendet werden.
- icon_path (String).
- tags (Array<String>).

[DONE]
Attribute-Stat-Verknuepfung (Data Table fuer backend/app/models/m_attribute_stat_link.py)
Struct FAttributeStatLink (optional separate Data Table, falls benoetigt):
- RowName: id
- id (String) - ULID.
- attribute_id (String) - ULID des Attributes.
- stat_id (String) - ULID des Stats.
- scale (Enum/String) - Linear, Exponential, Custom; Blueprint-Enum `EAttributeStatScale` mit denselben Strings verwenden.
- multiplier (Float) - Skalierungsfaktor.
Diese Tabelle erlaubt es, in UE5 blueprint-seitig alle Stat-Anpassungen pro Attribut zu iterieren.


Characters (Character Data Table) - Quelle: backend/app/models/m_characters.py
Struct FCharacterData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name (lesbar).
- name (String).
- title (String).
- description (Text).
- home_location_id (String) - ULID einer Location (optional).
- faction_id (String) - ULID einer Fraktion.
- class_id (String) - ULID einer CharacterClass (optional).
- level (Integer).
- image_path (String).
- tags (Array<String>).

Interaction Profiles (Interaction Profile Data Table) - Quelle: backend/app/models/m_interaction_profiles.py
Struct FInteractionProfileData:
- RowName: id
- id (String) - ULID.
- character_id (String) - ULID eines Characters.
- role (Enum/String) - `InteractionRole` (Questgiver, Merchant, Trainer, Companion, Story, Background); Blueprint-Enum `EInteractionRole` exakt nach diesen Bezeichnungen erstellen.
- dialogue_tree_id (String) - ULID eines Dialogs.
- available_quests (Array<String>) - Quest-ULIDs.
- inventory (Array<Struct>) - JSON aus { item_id, price }; in UE5 als `TArray<FInteractionItemForSale>` abbilden.
- flags_set_on_interaction (Array<String>) - Flag-ULIDs.
- tags (Array<String>).

Struct FInteractionItemForSale:
- item_id (String).
- price (Float).

Dialoge (Dialogue Data Table) - Quelle: backend/app/models/m_dialogues.py
Struct FDialogueData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- title (String) - interner Titel.
- character_id (String) - ULID eines Characters.
- location_id (String) - ULID einer Location.
- requirements_id (String) - ULID eines Requirement-Satzes.
- description (Text) - Notizen fuer Autoren.
- tags (Array<String>) - Stichwoerter.
Diese Tabelle bildet die Uebersicht aller Dialogfluesse ab; einzelne Knoten folgen in einer separaten Data Table.

Dialogknoten (Dialogue Node Data Table) - Quelle: backend/app/models/m_dialogue_nodes.py
Struct FDialogueNodeData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- dialogue_id (String) - ULID des uebergeordneten Dialogs.
- speaker (String) - Sprecher-Kennung (z.B. Character- oder Player-Slug).
- text (Text) - angezeigter Dialogtext.
- requirements_id (String) - ULID eines Requirement-Satzes (optional).
- choices (Array<Struct>) - Liste von Antwortoptionen { choice_text, next_node_id, requirements_id, flags_set }.
- set_flags (Array<String>) - Flags, die dieser Knoten setzt.
- tags (Array<String>).
In UE5 koennen Choices als eigener Struct `FDialogueChoice` modelliert werden.

Items (Item Data Table) - Quelle: backend/app/models/m_items.py
Struct FItemData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- type (Enum/String) - `ItemType` (Weapon, Armor, Accessory, Consumable, Tool, Material, Upgrade, Quest, SetPiece, Misc); Blueprint-Enum `EItemType` exakt nach Backend-Strings.
- rarity (Enum/String) - Common, Uncommon, Rare, Epic, Legendary; Blueprint-Enum `EItemRarity` verwenden.
- description (Text).
- base_price (Float).
- base_currency_id (String) - ULID einer Currency (optional).
- equipment_slot (Enum/String) - siehe `EquipmentSlot` im Backend; Blueprint-Enum `EEquipmentSlot` exakt nach Backend-Strings.
- weapon_type (Enum/String) - siehe `WeaponType` im Backend; Blueprint-Enum `EWeaponType`.
- damage_type (Enum/String) - Slashing, Piercing, Blunt, Elemental, Poison, Psychic, Light, Shadow; Blueprint-Enum `EDamageType`.
- weapon_range_type (Enum/String) - melee, range; Blueprint-Enum `EWeaponRangeType`.
- weapon_range (Integer) - numerischer Bereich/Distanzwert (Einheit im Design festlegen).
- effects (Array<String>) - Effekt-ULIDs.
- tags (Array<String>).
- icon_path (String).
- requirements_id (String) - ULID eines Requirement-Eintrags; optional Data Table `FRequirementData` nutzen.

Item Stat Modifiers (Item Stat Modifier Data Table) - Quelle: backend/app/models/m_items.py
Struct FItemStatModifierData (optional separate DataTable oder aus FItemData.stat_modifiers parsen):
- RowName: id
- id (String) - ULID.
- item_id (String) - ULID des Items.
- stat_id (String) - ULID des Stats.
- value (Float).
- value_type (Enum/String) - Flat, Percentage, Multiplier; Blueprint-Enum `EModifierValueType`.
- scaling_behavior (Enum/String) - None, Linear, Exponential, Custom Curve; Blueprint-Enum `EStatScalingBehavior`.
- notes (Text).
- order_index (Integer) - Reihenfolge im Item.

Item Attribute Modifiers (Item Attribute Modifier Data Table) - Quelle: backend/app/models/m_items.py
Struct FItemAttributeModifierData (optional separate DataTable oder aus FItemData.attribute_modifiers parsen):
- RowName: id
- id (String) - ULID.
- item_id (String) - ULID des Items.
- attribute_id (String) - ULID des Attributes.
- value (Float).
- scaling (Enum/String) - Linear, Exponential, Custom; Blueprint-Enum `EAttributeStatScale`.
- notes (Text).
- order_index (Integer) - Reihenfolge im Item.

Abilities (Ability Data Table) - Quelle: backend/app/models/m_abilities.py
Struct FAbilityData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- type (Enum/String) - Active, Passive, Toggle; Blueprint-Enum `EAbilityType` exakt nach Backend-Strings.
- icon_path (String).
- description (Text).
- resource_cost (Float).
- cooldown (Float).
- targeting (Enum/String) - Single, Area, Self, Allies, Enemies; Blueprint-Enum `EAbilityTargeting` mit denselben Namen.
- trigger_condition (Enum/String) - On Use, Passive, On Hit, When Damaged, On Kill; Blueprint-Enum `EAbilityTrigger` verwenden.
- requirements (Text/JSON) - als Raw JSON-String importieren oder in ein Struct parsen.
- tags (Array<String>).

Ability-Effekt-Verknuepfung - backend/app/models/m_abilities_links.py
Struct FAbilityEffectLink:
- RowName: id
- id (String) - ULID.
- ability_id (String) - ULID der Ability.
- effect_id (String) - ULID des Effekts.
Damit lassen sich in Blueprint alle Effekte einer Faehigkeit via ULID nachladen.

Ability-Scaling-Verknuepfung
Struct FAbilityScalingLink:
- RowName: id
- id (String) - ULID.
- ability_id (String).
- attribute_id (String).
- multiplier (Float) - Faktor fuer die Skalierung.
Optional kann ein Blueprint-Struct `FAbilityScaling` direkt in `FAbilityData` eingebettet werden, falls der Export die Arrays bereits expandiert.

Effects (Effect Data Table) - Quelle: backend/app/models/m_effects.py
Struct FEffectData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- type (Enum/String) - Status, Damage, Heal, Modifier, Reflect, Summon, Shield, Control; Blueprint-Enum `EEffectType` exakt uebernehmen.
- description (Text).
- target (Enum/String) - Self, Enemy, Ally, All, Area; Blueprint-Enum `EEffectTarget` mit gleichen Strings.
- duration (Float).
- value_type (Enum/String) - Flat, Percentage, None; Blueprint-Enum `EEffectValueType` mit identischen Namen.
- value (Float).
- attribute_id (String) - optionale ULID eines Attributes.
- scaling_stat_id (String) - optionale ULID eines Stats.
- trigger_condition (Enum/String) - None, On Hit, When Damaged, On Kill, On Cast, Passive; Blueprint-Enum `EEffectTriggerCondition` anlegen.
- stackable (Boolean).
- set_bonus_group (String).
- icon_path (String).
- related_items (Array<String>) - Item-ULIDs.
- tags (Array<String>).

Combat Profiles (Combat Profile Data Table) - Quelle: backend/app/models/m_combat_profiles.py
Struct FCombatProfileData:
- RowName: id
- id (String) - ULID.
- character_id (String) - ULID eines Characters.
- enemy_type (Enum/String) - beast, undead, humanoid, elemental, machine, boss, demon, dragon, giant, spirit, emanation, other; Blueprint-Enum `EEnemyType` exakt wie im Backend.
- aggression (Enum/String) - Hostile, Neutral, Friendly; Blueprint-Enum `EEnemyAggression` verwenden.
- custom_stats (Map<String, Float>) - individuelle Stat-Overrides.
- custom_abilities (Array<String>) - Ability-ULIDs.
- tags (Array<String>).
- loot_table (Array<Struct>) - { item_id, drop_chance } als `TArray<FLootEntry>`.
- currency_rewards (Array<Struct>) - { currency_id, amount, drop_chance }.
- reputation_rewards (Array<Struct>) - { faction_id, amount, drop_chance }.
- xp_reward (Float).
- related_quests (Array<String>) - Quest-ULIDs.
- companion_config (Struct/JSON) - optionale Overrides + Progression fuer Begleiter.

Struct FLootEntry:
- item_id (String).
- drop_chance (Float).

Struct FCurrencyReward:
- currency_id (String).
- amount (Float).
- drop_chance (Float).

Struct FReputationReward:
- faction_id (String).
- amount (Float).
- drop_chance (Float).

Struct FCompanionConfig:
- class_id (String) - optionaler Override fuer Combat Class.
- level (Integer) - optionaler Override fuer Startlevel.
- custom_abilities (Array<String>).
- custom_stats (Map<String, Float>).
- progression (Struct) - siehe FCompanionProgression.

Struct FCompanionProgression:
- level_cap (Integer).
- xp_multiplier (Float).
- stat_growth (Struct) - siehe FCompanionStatGrowth.

Struct FCompanionStatGrowth:
- hp (Float).
- attack (Float).
- defense (Float).
- speed (Float).
- mana (Float).
- spell_power (Float).

Encounters (Encounter Data Table) - Quelle: backend/app/models/m_encounters.py
Struct FEncounterData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- encounter_type (Enum/String) - Combat, Dialogue, Event; Blueprint-Enum `EEncounterType` mit identischen Strings.
- requirements_id (String) - ULID eines Requirement-Satzes.
- participants (Array<Struct>) - { character_id, contexts, combat_side }.
- rewards (Struct/JSON) - { xp, items, currencies, reputation, flags_set } als `FEncounterReward`.
- tags (Array<String>).

Struct FEncounterParticipant:
- character_id (String).
- contexts (Array<Enum/String>) - Combat, Interaction; Blueprint-Enum `EEncounterContext` mit exakt gleichen Strings.
- combat_side (Enum/String) - Hostile, Friendly, Neutral; optional, Blueprint-Enum `ECombatSide`.

Events (Event Data Table) - Quelle: backend/app/models/m_events.py
Struct FEventData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- title (String).
- type (Enum/String) - Encounter, ItemReward, LoreDiscovery, Dialogue, Teleport, ScriptedScene; Blueprint-Enum `EEventType` exakt nach Backend.
- requirements_id (String) - ULID eines Requirement-Satzes.
- location_id (String) - ULID einer Location.
- lore_id (String) - ULID eines Lore-Eintrags.
- dialogue_id (String) - ULID eines Dialogs.
- encounter_id (String) - ULID eines Encounters.
- item_rewards (Array<Struct>) - { item_id, quantity }.
- xp_reward (Float).
- currency_rewards (Array<Struct>) - { currency_id, amount }.
- reputation_rewards (Array<Struct>) - { faction_id, amount }.
- flags_set (Array<String>) - Flag-ULIDs.
- tags (Array<String>).
- next_event_id (String) - ULID fuer Ketten-Logik.

Factions (Faction Data Table) - Quelle: backend/app/models/m_factions.py
Struct FFactionData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- alignment (Enum/String) - Hostile, Neutral, Friendly; Blueprint-Enum `EFactionAlignment` mit identischen Strings.
- relationships (Map<String, String>) - Zuordnung anderer Fraktionen zu Einstufungen.
- reputation_config (Struct/JSON) - Grenzwerte fuer Rufstufen; als `FFactionReputationConfig` modellieren.
- tags (Array<String>).
- icon_path (String).

Flags (Flag Data Table) - Quelle: backend/app/models/m_flags.py
Struct FFlagData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- flag_type (Enum/String) - Story Progress, Quest State, Lore Discovery, Item Unlock, NPC Relationship, Companion Progress, Secret Discovery, Shop Unlock, Event Trigger, Other; Blueprint-Enum `EFlagType` mit exakt diesen Strings.
- default_value (Boolean).
- content_pack_id (String) - ULID eines Content Packs (optional).
- tags (Array<String>).

Locations (Location Data Table) - Quelle: backend/app/models/m_locations.py
Struct FLocationData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- biome (Enum/String) - Plains, Forest, Cave, Mountain, Desert, Swamp, Coast, Tundra, City, Ruins, Fortress, Sky Isles, Cloud Sea, Crystal Caverns, Magma Veins, Fungal Undergrowth, Abyss; Blueprint-Enum `ELocationBiome` mit denselben Namen.
- biome_modifier (Enum/String, optional) - Arcane, Corrupted, Divine, Shadowed, Dreamlike; Blueprint-Enum `ELocationBiomeModifier` ebenfalls exakt benennen.
- region (String) - freie Regionseinteilung.
- level_range (Struct/JSON) - { min, max } als `FLevelRange`.
- coordinates (Struct/JSON) - { x, y } fuer Karte oder Editor.
- image_path (String).
- encounters (Array<String>) - Encounter-ULIDs.
- is_safe_zone (Boolean).
- is_fast_travel_point (Boolean).
- has_respawn_point (Boolean).
- tags (Array<String>).

Location Routes (LocationRoute Data Table) - neue Export-Tabelle fuer das Reisesystem
Struct FLocationRouteData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name (z.B. `northpass_to_highridge`).
- from_location_id (String) - ULID der Quell-Location.
- to_location_id (String) - ULID der Ziel-Location.
- travel_time (Float) - Dauer in Spielstunden/-tagen.
- distance (Float) - Distanz oder Abstraktion fuer UI.
- requirements_id (String) - ULID eines Requirement-Satzes (Blockaden, Ruf, Story).
- encounter_weight_modifier (Float) - Multiplikator fuer Zufallsbegegnungen auf dieser Route.
- cost_currency_id (String, optional) - ULID einer Waehrung fuer Reisekosten.
- cost_amount (Float, optional) - Kostenbetrag.
- flags_unlock (Array<String>) - Flag-ULIDs, die beim Freischalten gesetzt werden.
- flags_lock (Array<String>) - Flag-ULIDs, bei deren Setzen die Route gesperrt wird.
- is_bidirectional (Boolean) - true, wenn dieselben Werte fuer Hin- und Rueckweg gelten; ansonsten zweite Zeile anlegen.
- tags (Array<String>) - Zusaetzliche Metadaten (z.B. `MountainPass`, `RequiresAirship`).
Diese Tabelle ermoeglicht den Aufbau eines Graphen in UE5 (`BP_WorldGraphSubsystem`) und spiegelt die neuen Reise-Workflows aus dem Plan wider.

Lore (Lore Entry Data Table) - Quelle: backend/app/models/m_lore_entries.py
Struct FLoreEntryData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- title (String).
- text (Text).
- location_id (String) - ULID einer Location.
- timeline_id (String) - ULID einer Timeline.
- related_story_arcs (Array<String>) - Story-Arc-ULIDs.
- tags (Array<String>).

Quests (Quest Data Table) - Quelle: backend/app/models/m_quests.py
Struct FQuestData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- title (String).
- description (Text).
- story_arc_id (String) - ULID eines Story-Arcs.
- requirements_id (String) - ULID eines Requirement-Satzes.
- objectives (Array<Struct>) - { objective_id, description, requirements_id, flags_set }.
- flags_set_on_completion (Array<String>) - Flag-ULIDs.
- xp_reward (Float).
- currency_rewards (Array<Struct>) - { currency_id, amount }.
- reputation_rewards (Array<Struct>) - { faction_id, amount }.
- item_rewards (Array<Struct>) - { item_id, quantity }.
- tags (Array<String>).

Story Arcs (Story Arc Data Table) - Quelle: backend/app/models/m_story_arcs.py
Struct FStoryArcData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- title (String).
- summary (Text).
- type (Enum/String) - Main Story, Side Arc, Faction Arc, DLC Arc; Blueprint-Enum `EStoryArcType` exakt uebernehmen.
- content_pack_id (String) - ULID eines Content Packs.
- timeline_id (String) - ULID einer Timeline.
- related_quests (Array<String>) - Quest-ULIDs.
- branching (Array<Struct>) - { quest_id, branches: [{ flag_id, next_quest_id }] }.
- required_flags (Array<String>) - Flag-ULIDs.
- tags (Array<String>).

Timelines (Timeline Data Table) - Quelle: backend/app/models/m_timelines.py
Struct FTimelineData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- start_year (Integer).
- end_year (Integer).
- tags (Array<String>).

Character Classes (Class Data Table) - Quelle: backend/app/models/m_characterclasses.py
Struct FCharacterClassData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- role (Enum/String) - Tank, Damage, Healer, Support, Hybrid; Blueprint-Enum `ECharacterRole` mit denselben Strings.
- base_stats (Map<String, Float>) - Startwerte.
- stat_growth (Map<String, Float>) - Zuwachse pro Level.
- starting_abilities (Array<String>) - Ability-ULIDs.
- preferred_attributes (Array<String>) - Attribute-ULIDs.
- starting_equipment (Array<String>) - Item-ULIDs.
- tags (Array<String>).

Shops (Shop Data Table) - Quelle: backend/app/models/m_shops.py
Struct FShopData:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- name (String).
- description (Text).
- price_modifier (Float).
- price_multiplier (Float).
- price_override (Float).
- currency_id (String) - ULID einer Currency (optional).
- location_id (String) - ULID einer Location.
- character_id (String) - ULID eines Characters (optional).
- requirements_id (String) - ULID eines Requirement-Datensatzes.
- price_modifiers (Struct/JSON) - Regeln fuer Rabatte/Aufschlaege.
- tags (Array<String>).

Shop-Inventory (ShopInventory Data Table) - Quelle: backend/app/models/m_shop_inventory.py
Struct FShopInventoryItem:
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name (z.B. Kombination aus Shop und Item).
- shop_id (String) - ULID des Shops.
- item_id (String) - ULID des Items.
- price_modifier (Float).
- price_multiplier (Float).
- price_override (Float).
- currency_id (String) - ULID einer Currency (optional).
- stock (Integer) - `-1` oder leer = unbegrenzt.
- requirements_id (String) - ULID eines Requirement-Eintrags.
- tags (Array<String>).

Requirements (Requirement Data Table) - Quelle: backend/app/models/m_requirements.py
Struct FRequirementData (optional):
- RowName: slug
- id (String) - ULID.
- slug (String) - Row Name.
- tags (Array<String>).
Dazu optionale Link-Tabellen als separate Data Tables, falls im Spiel benoetigt:
- RequirementRequiredFlag: id, requirement_id, flag_id.
- RequirementForbiddenFlag: id, requirement_id, flag_id.
- RequirementMinFactionReputation: id, requirement_id, faction_id, min_value.

Import- und Blueprint-Hinweise
- Arrays/Maps aus JSON lassen sich mit JSON-Data-Table-Import direkt nach UE5 holen. Alternativ CSV-Exports erzeugen, bei denen Array-Felder als `[]`-Schreibweise (JSON) bleiben; UE5 parst diese in `TArray`/`TMap`, wenn die Struct entsprechend definiert ist.
- Fuer alle Enum-Felder lohnt sich ein Blueprint-Enum, dessen Display-Namen exakt den Strings aus den Modellen entsprechen. So verhindert ihr Tippfehler nach dem Import.
- ULIDs bleiben als `FString`. Bei haeufiger Nutzung kann zusaetzlich ein `FName`-Feld (z.B. `IdName`) in der Struct befuellt werden, das per Blueprint in `PreConstruct` gesetzt wird (`Conv_StringToName`), damit Data-Table-Lookups schneller funktionieren.
- Querverweise (z.B. Ability -> Effects, Item -> Requirements, Event -> Encounter) sollten im Blueprint-Code via Helper-Funktionen geloest werden, die ueber die Data Tables anhand der ULID-Strings nachschlagen und bei fehlenden Eintraegen Warnungen ausgeben. Dadurch bleibt der Datenfluss identisch zum Backend.
- Editor-Workflows: Nach einem Export aus dem SoA-Editor CSV/JSON-Dateien in `Content/Data/Exports` legen, `Structs` aktualisieren und `Reimport` auf der jeweiligen Data Table ausfuehren. Prueft die Output-Log auf Fehlermeldungen zu fehlenden Zeilennamen (haeufig Zeichenketten, die nicht exakt mit ULID oder Slug uebereinstimmen).

Mit diesen Structs und Data Tables steht in UE5 eine vollstaendige 1:1-Abbildung der SoA-Datenmodelle bereit. Designers koennen die Inhalte datengetrieben anpassen, waehrend Blueprints ueber stabile ULID-Verknuepfungen und Slugs als lesbare Schluessel auf alle Werte zugreifen.
